import{_ as l,r as o,o as c,c as i,e,a as s,b as a,d as p}from"./app-CZkYE20v.js";const u="/assets/large-HT-OYG-hero-1-B2NQ9x3i.jpg",r="/assets/tutorial4-CclRnEXN.jpg",d="/assets/tutorial3-DFq-orgu.jpg",m="/assets/tutorial2-CSd9iVP_.jpg",k="/assets/tutoria1-c-mFLRAP.jpg",v={},g={href:"https://en.wikipedia.org/wiki/Short-circuit_evaluation",target:"_blank",rel:"noopener noreferrer"},h={href:"https://en.wikipedia.org/wiki/Hash_function",target:"_blank",rel:"noopener noreferrer"};function b(_,n){const t=o("ExternalLinkIcon");return c(),i("div",null,[n[9]||(n[9]=e('<p><img src="'+u+'" alt="How To Optimise Your Games"></p><p>在使用 GameMaker 制作游戏的过程中，最常被问到的就是：如何优化游戏，并使其尽可能高效地运行。</p><p>虽然没有适用于所有项目的简单答案，但在所有项目中都可以遵循一些通用的 “经验法则”，这将有助于您最大限度地利用 GameMaker。</p><h2 id="图形" tabindex="-1"><a class="header-anchor" href="#图形"><span>图形</span></a></h2><p>图形管道是造成游戏运行缓慢和卡顿的最常见原因之一，因此您需要确保以最高效的方式绘制所有内容。下面是一些实现这一目标的技巧。</p><h3 id="纹理页" tabindex="-1"><a class="header-anchor" href="#纹理页"><span>纹理页</span></a></h3><p>GameMaker 将所有游戏图形存储在 <strong>纹理页</strong> 上。纹理页是一整张图像，所有游戏图形都分布在其中，运行时可以从中 “提取” 出来图形在屏幕上绘制。</p><p>现在，当您为游戏创建了许多图形时，它们可能会开始占用一个以上的纹理页，这会导致它们分散到多个不同的纹理页上。GameMaker 在屏幕上绘制这些图形时，可能需要执行 <strong>纹理交换</strong> ，以便从正确的页面获取正确的精灵，这在只有几页的情况下问题不大，但当这些图形分散在许多页面上时，这种连续的交换可能会导致延迟和卡顿。</p><p>如何避免这种情况？您可以为游戏创建 <strong>纹理组</strong> ，然后在房间开始时从纹理内存中刷新和预取未使用的图形，这意味着内存中只保留了实际要使用的图形。</p><p>首先，您应该从 IDE 顶部的 <strong>工具</strong> 菜单中打开 <strong>纹理组编辑器</strong>。在这里，您可以创建所需的纹理组 —— 例如，如果您有一些只出现在主菜单中的图形，那么就为它们创建一个组。如果您有一系列只在单个关卡/房间中出现的图形（包括精灵和背景），就为它们创建一个组，等等。</p><p><img src="'+r+'" alt="undefined"></p><p>有了组之后，就可以使用 “<em>添加资产</em>” 按钮查看精灵和背景，并将每个精灵和背景分配到一个特定的组中，也可以查看每个精灵，然后从资产窗口中的 <strong>组</strong> 下拉菜单中设置纹理组：</p><p><img src="'+d+`" alt="undefined"></p><p>这样，您就已经对游戏进行了相当程度的优化，因为这将限制所需的纹理交换，特定房间的所有图形现在都应该在同一页面上。</p><p>至于从内存中清除不需要的页面，您可以在每个房间的第一个实例的 <strong>创建事件</strong> 中（可在房间编辑器中设置）使用函数来完成：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">draw_texture_flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此函数将清除纹理内存中的所有图像数据。请注意，这可能会导致在运行绘制事件（Draw Event）时首次加载新纹理时出现短暂的闪烁，因此为了避免这种情况，您还应在同一事件中 “初始化” 纹理，只需调用一个 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Manipulation/sprite_prefetch.htm?rhsearch%3Dpre%20fetch%26rhhlterm%3Dpre%20fetch">预获取函数</a>（每个所需页面一个）即可。由于这是在创建事件中进行的，所以不会被人看到，但可以防止在实际绘制游戏图形时出现任何闪烁。最终的创建事件将如下所示：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">draw_texture_flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sprite_prefetch</span><span class="token punctuation">(</span><span class="token constant">spr_logo</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">sprite_prefetch</span><span class="token punctuation">(</span><span class="token constant">spr_menu</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请记住 <em>您只需为每个纹理页预取一个图形！</em> 您可以在每个平台的 <strong>游戏选项</strong> 中查看如何将精灵打包到每个纹理页上。</p><p><img src="`+m+'" alt="undefined"></p><p>通过点击游戏选项中 <strong>图形</strong> 部分的 “<em>预览</em>” 按钮，您可以看到完成后的纹理页面的外观。这样，您就可以看到所有图像是在一个页面上还是在多个页面上，并决定如何创建和分配组和页面。</p><p><img src="'+k+`" alt="undefined"></p><h3 id="动态纹理" tabindex="-1"><a class="header-anchor" href="#动态纹理"><span>动态纹理</span></a></h3><p>您还可以将纹理组标记为 <a href="/tool/manual.html?path=Settings/Texture_Information/Dynamic_Textures.htm">动态</a> 。虽然可以预取和刷新纹理组，以便从显存（VRAM）中加载和卸载纹理组，但它们仍保存在 RAM 中。动态纹理组可以将纹理组保存在磁盘上，只有在需要时才将其加载到 RAM（随后加载到 VRAM）中。加载动态纹理组的方法是使用函数：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">texturegroup_load</span><span class="token punctuation">(</span>groupname<span class="token punctuation">,</span> <span class="token punctuation">[</span>prefetch<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>卸载是通过以下函数完成的：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">texturegroup_unload</span><span class="token punctuation">(</span>groupname<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="运行时添加资产" tabindex="-1"><a class="header-anchor" href="#运行时添加资产"><span>运行时添加资产</span></a></h3><p>在 GameMaker 中可以从外部载入精灵，也可以使用 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Manipulation/sprite_add.htm">sprite_add()</a> 等函数创建新资产。不过，以这种方式创建的每个新资产都会 <strong>创建一个新的纹理页</strong> ，这意味着（例如）添加 10 个新的精灵将创建 10 个<em>新的纹理页</em>！而每次绘制这些精灵时，都会进行一次新的纹理交换，并中断显卡的批处理。</p><p>可以想象，这样做的效率并不高，因此（与以前版本的 GameMaker 不同）应避免这样做，而应在 IDE 中将所有图形资产添加到游戏捆绑包中。请注意，您可以使用这些函数来添加/创建少量图片，它们不会对性能产生负面影响，但应避免以这种方式添加大量图片，因为这将会产生影响。</p><p><strong>注意：</strong> 函数 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Manipulation/sprite_add.htm"><em>sprite_add()</em></a> <em>在精灵加载完成之前，该函数会阻止代码的进一步执行。您可以使用</em> <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Manipulation/sprite_add_ext.htm"><em>sprite_add_ext()</em></a> 以异步方式加载精灵。</p><h2 id="绘制优化" tabindex="-1"><a class="header-anchor" href="#绘制优化"><span>绘制优化</span></a></h2><h3 id="深度缓冲区" tabindex="-1"><a class="header-anchor" href="#深度缓冲区"><span>深度缓冲区</span></a></h3><p>深度缓冲区存储了表面上每个像素的深度值（或 Z 值），也就是像素到摄像机的距离。默认情况下，创建的所有表面都有一个深度缓冲区。每当在表面上绘制新内容时，深度值都会在启用 Z 写入（默认会启用）后被写入深度缓冲区：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">gpu_set_zwriteenable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不过，如果游戏允许，您可以在处理表面时使用 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm">surface_depth_disable</a> 禁用深度缓冲区，然后让绘制顺序来处理一切。禁用深度缓冲区后，创建的曲面将不会带有深度缓冲区。要禁用深度缓冲区，请在创建表面前调用以下命令：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">surface_depth_disable</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>禁用深度缓冲区时，也无需在像素之间进行深度比较，也无需写入任何深度信息：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">gpu_set_zwriteenable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gpu_set_ztestenable</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>毕竟，所有东西都是前后绘制的，所以后面绘制的任何东西都是在前面绘制的基础上绘制的。</p><h3 id="混合模式" tabindex="-1"><a class="header-anchor" href="#混合模式"><span>混合模式</span></a></h3><p>绘制时，GameMaker 会通过图形管道发送 “批” 图形数据进行绘制，显然您希望尽可能减少这一操作的频率。通常情况下您不需要担心这个问题，但如果您使用 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm?rhsearch%3Dblend%20mode%26rhhlterm%3Dblend%20mode">混合模式</a> 进行绘制，那么每次调用设置混合模式都会破坏当前的纹理批次，而多个实例的多次调用可能会对您的游戏产生不利影响。</p><p>如何解决这个问题？尝试只使用一个实例来设置混合模式，然后绘制所有需要的内容。例如：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token function">gpu_set_blendmode</span><span class="token punctuation">(</span><span class="token constant">bm_add</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">with</span> <span class="token punctuation">(</span><span class="token constant">obj_HUD</span><span class="token punctuation">)</span> <span class="token function">draw_sprite</span><span class="token punctuation">(</span><span class="token constant">spr_Marker</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mx<span class="token punctuation">,</span> my<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">with</span> <span class="token punctuation">(</span><span class="token constant">obj_Player</span><span class="token punctuation">)</span> <span class="token function">draw_sprite</span><span class="token punctuation">(</span><span class="token constant">spr_HaloEffect</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">x</span><span class="token punctuation">,</span> <span class="token variable">y</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">with</span> <span class="token punctuation">(</span><span class="token constant">obj_Cursor</span><span class="token punctuation">)</span> <span class="token function">draw_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">gpu_set_blendmode</span><span class="token punctuation">(</span><span class="token constant">bm_normal</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这将为单个批处理调用设置混合模式，而不是为每个引用实例设置三个单独的混合模式。</p><p><strong>注意：</strong> <em>其他可能导致批处理失败的情况包括绘制形状、使用绘制健康条功能、使用着色器、设置uniforms和更改渲染目标。</em></p><h3 id="alpha-混合和-alpha-测试" tabindex="-1"><a class="header-anchor" href="#alpha-混合和-alpha-测试"><span>Alpha 混合和 Alpha 测试</span></a></h3><p>GameMaker 中有两个绘制功能经常被忽视，但它们都能大大加快绘制过程。它们是：</p><ul><li><a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_alphatestenable.htm?rhsearch%3Dalphatest%26rhhlterm%3Dalphatest">gpu_set_alphatestenable()</a></li><li><a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_blendenable.htm?rhsearch%3Dblend%20enable%26rhhlterm%3Dblend%20enable">gpu_set_blendenable()</a></li></ul><p>这些功能有什么帮助呢？第一种方法可以启用 <strong>Alpha 测试</strong>，基本上是检查每个像素的 Alpha 值，如果它高于混合阈值（0 到 255 之间的一个值），就会被绘制出来。从本质上讲，这将 “丢弃” 任何 Alpha 值低于测试值的像素，也就是说永远不会绘制它（因为即使 Alpha 值为零的像素也会正常 “绘制”），这也是加快没有 Alpha 梯度的复古像素艺术图形游戏速度的绝佳方法。请注意，您可以使用函数 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_alphatestref.htm?rhsearch%3Dalphatestref%26rhhlterm%3Dalphatestref">gpu_set_alphatestref()</a> 设置 Alpha 测试参考值。</p><p>Alpha 混合功能的作用与此不同，它可以用来关闭所有 Alpha 混合功能。这意味着绘制的任何带有 Alpha 的精灵或背景都将是完全不透明的。该功能可在绘制过程中的任何时候使用，因此如果您正在手动绘制一个没有 Alpha 的背景，那么您可以关闭 Alpha 混合功能，绘制背景，然后在接下来的绘制过程中再次开启。在某些游戏中，这可以大大提高速度，因此如果你正在绘制不需要 Alpha 的东西，可以考虑关闭它（注意，它可以根据需要随时启用或禁用，而且开销很小）。</p><h3 id="层开始和结束脚本" tabindex="-1"><a class="header-anchor" href="#层开始和结束脚本"><span>层开始和结束脚本</span></a></h3><p>您还可以使用层开始和结束脚本。您可以在层开始脚本中进行所需的更改，然后在层结束脚本中将其重置。这提供了一种简洁、有序的方式，以相同的方式绘制给定层上的所有实例或资产，同时将它们的代码保留在绘制事件中，并且不会破坏批处理。</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code>function <span class="token function">blend_additive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">event_type</span> <span class="token operator">==</span> <span class="token constant">ev_draw</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">event_number</span> <span class="token operator">==</span> ev_draw_normal<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       <span class="token function">gpu_set_blendmode</span><span class="token punctuation">(</span><span class="token constant">bm_add</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
function <span class="token function">blend_normal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">event_type</span> <span class="token operator">==</span> <span class="token constant">ev_draw</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">event_number</span> <span class="token operator">==</span> ev_draw_normal<span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       <span class="token function">gpu_set_blendmode</span><span class="token punctuation">(</span><span class="token constant">bm_normal</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>脚本会在每个 <em>不同的绘制</em> 事件开始时运行，因此您可能需要检查当前的绘制事件是否是您要执行脚本的事件。</p><p>然后在 房间创建代码 或实例的 创建事件/房间开始事件 中分配脚本：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token keyword">var</span> _layer_id <span class="token operator">=</span> <span class="token function">layer_get_id</span><span class="token punctuation">(</span><span class="token string">&quot;Instances&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">layer_script_begin</span><span class="token punctuation">(</span>_layer_id<span class="token punctuation">,</span> blend_additive<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">layer_script_end</span><span class="token punctuation">(</span>_layer_id<span class="token punctuation">,</span> blend_normal<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用叠加混合法绘制 “实例” 图层上的所有内容。</p><p><strong>注意</strong>：<em>在这种情况下，您应确保图层上的任何实例都不会在其绘制代码中破坏批次。</em></p><h2 id="声音" tabindex="-1"><a class="header-anchor" href="#声音"><span>声音</span></a></h2><p>在 GameMaker 中添加声音时，有许多关于最终输出声音文件的格式和质量的可用选项。这些选项应根据以下基本规则自动设置：</p><ul><li>如果是声音效果（或任何只有几秒钟的简短声音片段），则应<strong>不压缩(uncompressed)</strong>。</li><li>如果是声音效果，但超过几秒钟，或者在游戏中只是偶尔使用，则可以<strong>压缩(compressed)</strong>。</li><li>如果是大型音效且在游戏中频繁使用，则应<strong>压缩但加载时不压缩(compressed but uncompressed on load)</strong>。</li><li>如果是音乐，则应<strong>压缩从磁盘串流(compressed streamed from disk)</strong>。</li></ul><p>除了压缩和串流选项外，您还可以设置音质。这些设置应尽可能接近用于创建要添加的原始文件的设置。因此，如果你的MP3曲目是22050kHz和56kbps，这些都是你应该使用的质量设置。如果您不确定要使用的实际值，请保留GameMaker为您设置的默认值。</p><h2 id="代码建议" tabindex="-1"><a class="header-anchor" href="#代码建议"><span>代码建议</span></a></h2><p>就代码而言提供建议可能很困难，因为每个人都有自己的看法，什么对一个人有效，什么对另一个人可能无效。但在使用GameMaker时，有一些事情需要注意，这对每个人来说都是正确的。</p><h3 id="提前退出-if" tabindex="-1"><a class="header-anchor" href="#提前退出-if"><span>提前退出 if</span></a></h3><p>GameMaker 对于 <a href="/tool/manual.html?path=GameMaker_Language/GML_Overview/Language_Features/If_Else_and_Conditional_Operators.htm">if</a> 语句有一个提前退出机制。 考虑以下代码：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mouse_check_button</span><span class="token punctuation">(</span><span class="token constant">mb_left</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">mouse_x</span> <span class="token operator">&gt;</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">global</span><span class="token punctuation">.</span>canshoot <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token comment">// 一些功能</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这里，我们计算三个不同的表达式，如果它们都为true，那么其余的代码将运行。但是，如果其中任何一个返回false，那么代码将不会运行。这样做的好处是，如果第一个是假的，那么其余的甚至都不会被检查，这意味着在创建具有多个检查的“if”语句时，将开销最大的语句放在最后，并尝试将最不可能评估为真的语句先放在最后面，以充分利用这个“提前退出”系统。</p>`,69)),s("p",null,[n[1]||(n[1]=s("strong",null,"注意：",-1)),n[2]||(n[2]=a(" 这项功能也常被称为 ")),s("a",g,[n[0]||(n[0]=a("短路求值")),p(t)]),n[3]||(n[3]=a("."))]),n[10]||(n[10]=e(`<h3 id="不要计算每一步" tabindex="-1"><a class="header-anchor" href="#不要计算每一步"><span>不要计算每一步</span></a></h3><p>有时你可能有一个复杂的算法来寻路或者提供敌人的AI... 每一步都运行这个程序可能会让CPU无法保持 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/General_Game_Control/game_set_speed.htm">游戏速度</a>。在这些情况下，设置 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/alarm.htm">计时器</a> 可能很有用并且仅在计时器触发时执行代码。</p><h2 id="变量" tabindex="-1"><a class="header-anchor" href="#变量"><span>变量</span></a></h2><p>使用 <a href="/tool/manual.html?path=GameMaker_Language/GML_Overview/Variables/Global_Variables.htm">全局变量</a> 是使所有实例都可以访问控制器变量的好方法。然而，应该注意的是，引用它们的脚本调用（尤其是在编译到YYC时）可能会因全局变量的多次查找而减慢速度。例如，考虑以下脚本：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token keyword">repeat</span><span class="token punctuation">(</span><span class="token variable">argument0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token operator">with</span> <span class="token punctuation">(</span><span class="token constant">obj_Parent</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token function">place_meeting</span><span class="token punctuation">(</span><span class="token constant">global</span><span class="token punctuation">.</span>px<span class="token punctuation">,</span> <span class="token constant">global</span><span class="token punctuation">.</span>py<span class="token punctuation">,</span> <span class="token variable">argument1</span><span class="token punctuation">)</span> <span class="token function">instance_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的问题是，重复循环的每次迭代都必须查找全局变量的值，这是非常缓慢的。为了避免这种情况，您应该始终将要像这样使用的任何全局变量分配给 <a href="/tool/manual.html?path=GameMaker_Language/GML_Overview/Variables/Local_Variables.htm">局部变量</a>. 因此，我们的代码示例将变为：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token keyword">var</span> _xx <span class="token operator">=</span> <span class="token constant">global</span><span class="token punctuation">.</span>px<span class="token punctuation">;</span>
<span class="token keyword">var</span> _yy <span class="token operator">=</span> <span class="token constant">global</span><span class="token punctuation">.</span>py<span class="token punctuation">;</span>
<span class="token keyword">repeat</span><span class="token punctuation">(</span><span class="token variable">argument0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token operator">with</span> <span class="token punctuation">(</span><span class="token constant">obj_Parent</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token function">place_meeting</span><span class="token punctuation">(</span>_xx<span class="token punctuation">,</span> _yy<span class="token punctuation">,</span> <span class="token variable">argument1</span><span class="token punctuation">)</span> <span class="token function">instance_destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="局部变量" tabindex="-1"><a class="header-anchor" href="#局部变量"><span>局部变量</span></a></h3><p>如上所述，<a href="/tool/manual.html?path=GameMaker_Language/GML_Overview/Variables/Local_Variables.htm?rhsearch%3Dlocal%20variables%26rhhlterm%3Dlocal%20variables">局部变量</a> 是在脚本或代码块中创建的 “局部 ”变量，其查找时间非常快。这意味着它们是存储代码中需要重复使用的函数调用值或操作的理想选择。例如，如果要绘制相对于视图中心的图形，只需计算一次该点，然后将其坐标存储到几个局部变量中，供以后使用：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token keyword">var</span> _xx <span class="token operator">=</span> <span class="token function">camera_get_view_x</span><span class="token punctuation">(</span>view_camera<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">camera_get_view_width</span><span class="token punctuation">(</span>view_camera<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> _xx <span class="token operator">=</span> <span class="token function">camera_get_view_y</span><span class="token punctuation">(</span>view_camera<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">camera_get_view_height</span><span class="token punctuation">(</span>view_camera<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">draw_sprite</span><span class="token punctuation">(</span><span class="token constant">spr_Crosshair</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> _xx<span class="token punctuation">,</span> _yy<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">draw_text</span><span class="token punctuation">(</span>_xx<span class="token punctuation">,</span> _yy<span class="token punctuation">,</span> dist<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个简单的示例代码中，我们只需先将变量赋值给局部变量，就可以 <em>减少</em> 操作。在大型代码块中，这可以起到显著的优化作用，你应该始终关注如何压缩代码，以减少操作或函数调用的次数。同样值得注意的是，如果在代码中使用超过一次，在任何实例上进行的任何变量查找都将受益于存储在局部变量中，这一点在使用 YYC 编译时尤为明显。</p><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组"><span>数组</span></a></h3><p>对于 <a href="/tool/manual.html?path=GameMaker_Language/GML_Overview/Arrays.htm">数组</a>，一个简单的优化技巧就是以相反的顺序初始化它们。这样，GameMaker 将为整个数组分配整块内存，而不是 “一点一点” 地分配。因此，举例来说，如果你只想将数组初始化为 0，你可以这样做，而不是循环：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code>myarray<span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// 或者</span>

<span class="token function">array_create</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这将会创建一个容量为100的数组，初始化到0。如果需要为每个数组索引赋值，则使用一个从大到小的For循环。</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">;</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   myarray<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make_color_hsv</span><span class="token punctuation">(</span><span class="token function">irandom</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是，HTML5 的情况 <em>并非如此</em> ，因为它对数组的处理方式不同。这意味着您应从 0 开始初始化数组，而不是在此平台上反向初始化。</p><blockquote><p>译者：HTML5 平台使用的是 JavaScript 语言，这与 YYC 所生成的 C++ 语言有着本质区别。C++ 的数组是 “内存结构” 的数组，是存储相同数据类型的一块连续的存储空间，因此空间的大小必须要提前设定好才可以。而 JavaScript 的数组是 “语言规定” 的数组，虽然名字一样，但实现天差地别。对于GameMaker来说，JavaScript 数组的本质是哈希表 (与下文的结构体类似)。</p></blockquote><h3 id="结构体" tabindex="-1"><a class="header-anchor" href="#结构体"><span>结构体</span></a></h3>`,19)),s("p",null,[n[5]||(n[5]=a("另一项优化与 ")),n[6]||(n[6]=s("a",{href:"/tool/manual.html?path=GameMaker_Language/GML_Overview/Structs.htm"},"结构体",-1)),n[7]||(n[7]=a(" 有关。访问结构变量时，GameMaker 会根据变量名（字符串）计算出一个 ")),s("a",h,[n[4]||(n[4]=a("哈希")),p(t)]),n[8]||(n[8]=a("，这基本上就是变量在内存中位置的键。使用哈希值访问变量的速度很快，但计算哈希值本身的速度相对较慢，这就好比使用密钥：使用密钥很容易，创建密钥却很难，因此应避免不断创建新的密钥。当编译器检测到变量名是常量时，它会提前计算变量的哈希值，并用游戏可执行文件中 “硬编码” 的哈希值取代哈希计算值。这样，在游戏运行时，访问变量的哈希值就不需要计算了。例如："))]),n[11]||(n[11]=e(`<div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token comment">/// 创建事件</span>
my_struct <span class="token operator">=</span>
<span class="token punctuation">{</span>
   a<span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>
   b<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
   c<span class="token punctuation">:</span> <span class="token number">9</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/// 步事件</span>
my_struct<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token variable">x</span><span class="token punctuation">;</span>  <span class="token comment">// 变量名 “a” 在整个游戏过程中都不会改变，因此编译器可以对其进行优化</span>
<span class="token comment">// 或者:</span>
<span class="token comment">// my_struct[$ &quot;a&quot;] = x;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当变量名在编译时不是常量时，GameMaker 无法预先知道哈希值应该是多少（它取决于变量当时的值），因此需要重新计算哈希值。在这种情况下，您仍然可以通过使用 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Variable_Functions/variable_get_hash.htm">variable_get_hash</a> 一次获取变量的哈希值，并使用 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Variable_Functions/struct_get_from_hash.htm">struct_get_from_hash</a> 和 <a href="/tool/manual.html?path=GameMaker_Language/GML_Reference/Variable_Functions/struct_set_from_hash.htm">struct_set_from_hash</a> 获取和设置结构变量来优化自己的工作：</p><div class="language-gml line-numbers-mode" data-ext="gml" data-title="gml"><pre class="language-gml"><code><span class="token comment">/// 创建事件</span>
my_struct <span class="token operator">=</span>
<span class="token punctuation">{</span>
   a<span class="token punctuation">:</span> <span class="token number">7</span><span class="token punctuation">,</span>
   b<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">,</span>
   c<span class="token punctuation">:</span> <span class="token number">9</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">randomise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
varname <span class="token operator">=</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 编译时无法知道 varname 的内容</span>
varname_hash <span class="token operator">=</span> <span class="token function">variable_get_hash</span><span class="token punctuation">(</span>varname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取 varname 当前持有的变量名的哈希值</span>

<span class="token comment">/// 步事件</span>
<span class="token comment">// my_struct[$ varname] = x;                // 在这里，GameMaker 需要每一步都根据名称重新计算哈希值</span>
<span class="token function">struct_set_from_hash</span><span class="token punctuation">(</span>my_struct<span class="token punctuation">,</span> varname_hash<span class="token punctuation">,</span> <span class="token variable">x</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这里直接使用哈希值</span>

<span class="token comment">/// 按键事件 - 空格</span>
varname <span class="token operator">=</span> <span class="token function">choose</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;b&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 改为访问另一个随机结构变量</span>
varname_hash <span class="token operator">=</span> <span class="token function">variable_get_hash</span><span class="token punctuation">(</span>varname<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 相应更新哈希值！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接使用哈希值可以有效绕过根据变量名计算哈希值的过程。只要 varname 保持不变，GameMaker 就不必重新计算哈希值。 请注意，在更改 varname 时，也必须更新哈希值。</p>`,4))])}const M=l(v,[["render",b],["__file","HowToOptimiseYourGames.html.vue"]]),x=JSON.parse('{"path":"/blogs/2024/5/HowToOptimiseYourGames.html","title":"如何优化你的GameMaker游戏","lang":"en-US","frontmatter":{"title":"如何优化你的GameMaker游戏","date":"2024/01/24","categories":["官方教程"]},"headers":[{"level":2,"title":"图形","slug":"图形","link":"#图形","children":[{"level":3,"title":"纹理页","slug":"纹理页","link":"#纹理页","children":[]},{"level":3,"title":"动态纹理","slug":"动态纹理","link":"#动态纹理","children":[]},{"level":3,"title":"运行时添加资产","slug":"运行时添加资产","link":"#运行时添加资产","children":[]}]},{"level":2,"title":"绘制优化","slug":"绘制优化","link":"#绘制优化","children":[{"level":3,"title":"深度缓冲区","slug":"深度缓冲区","link":"#深度缓冲区","children":[]},{"level":3,"title":"混合模式","slug":"混合模式","link":"#混合模式","children":[]},{"level":3,"title":"Alpha 混合和 Alpha 测试","slug":"alpha-混合和-alpha-测试","link":"#alpha-混合和-alpha-测试","children":[]},{"level":3,"title":"层开始和结束脚本","slug":"层开始和结束脚本","link":"#层开始和结束脚本","children":[]}]},{"level":2,"title":"声音","slug":"声音","link":"#声音","children":[]},{"level":2,"title":"代码建议","slug":"代码建议","link":"#代码建议","children":[{"level":3,"title":"提前退出 if","slug":"提前退出-if","link":"#提前退出-if","children":[]},{"level":3,"title":"不要计算每一步","slug":"不要计算每一步","link":"#不要计算每一步","children":[]}]},{"level":2,"title":"变量","slug":"变量","link":"#变量","children":[{"level":3,"title":"局部变量","slug":"局部变量","link":"#局部变量","children":[]},{"level":3,"title":"数组","slug":"数组","link":"#数组","children":[]},{"level":3,"title":"结构体","slug":"结构体","link":"#结构体","children":[]}]}],"git":{"createdTime":1726466709000,"updatedTime":1726466709000,"contributors":[{"name":"Feafly","email":"jjcyf@foxmail.com","commits":1}]},"filePathRelative":"blogs/2024/5/HowToOptimiseYourGames.md"}');export{M as comp,x as data};
